/**
* @license Angular v10.1.0-next.6+7.sha-aaa1d8e
* (c) 2010-2020 Google LLC. https://angular.io/
* License: MIT
*/
!function(e){"function"==typeof define&&define.amd?define(e):e()}((function(){"use strict";
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */!function(e){const t=e.Date;function r(){if(0===arguments.length){const e=new t;return e.setTime(r.now()),e}{const e=Array.prototype.slice.call(arguments);return new t(...e)}}r.now=function(){const e=Zone.current.get("FakeAsyncTestZoneSpec");return e?e.getCurrentRealTime()+e.getCurrentTime():t.now.apply(this,arguments)},r.UTC=t.UTC,r.parse=t.parse;const s={setTimeout:e.setTimeout,setInterval:e.setInterval,clearTimeout:e.clearTimeout,clearInterval:e.clearInterval};class i{constructor(){this._schedulerQueue=[],this._currentTime=0,this._currentRealTime=t.now(),this._currentTickRequeuePeriodicEntries=[]}getCurrentTime(){return this._currentTime}getCurrentRealTime(){return this._currentRealTime}setCurrentRealTime(e){this._currentRealTime=e}scheduleFunction(e,t,r){let s=(r=Object.assign({args:[],isPeriodic:!1,isRequestAnimationFrame:!1,id:-1,isRequeuePeriodic:!1},r)).id<0?i.nextId++:r.id,n={endTime:this._currentTime+t,id:s,func:e,args:r.args,delay:t,isPeriodic:r.isPeriodic,isRequestAnimationFrame:r.isRequestAnimationFrame};r.isRequeuePeriodic&&this._currentTickRequeuePeriodicEntries.push(n);let a=0;for(;a<this._schedulerQueue.length&&!(n.endTime<this._schedulerQueue[a].endTime);a++);return this._schedulerQueue.splice(a,0,n),s}removeScheduledFunctionWithId(e){for(let t=0;t<this._schedulerQueue.length;t++)if(this._schedulerQueue[t].id==e){this._schedulerQueue.splice(t,1);break}}tick(t=0,r,s){let i=this._currentTime+t,n=0;const a=(s=Object.assign({processNewMacroTasksSynchronously:!0},s)).processNewMacroTasksSynchronously?this._schedulerQueue:this._schedulerQueue.slice();if(0===a.length&&r)r(t);else{for(;a.length>0&&(this._currentTickRequeuePeriodicEntries=[],!(i<a[0].endTime));){let t=a.shift();if(!s.processNewMacroTasksSynchronously){const e=this._schedulerQueue.indexOf(t);e>=0&&this._schedulerQueue.splice(e,1)}if(n=this._currentTime,this._currentTime=t.endTime,r&&r(this._currentTime-n),!t.func.apply(e,t.isRequestAnimationFrame?[this._currentTime]:t.args))break;s.processNewMacroTasksSynchronously||this._currentTickRequeuePeriodicEntries.forEach(e=>{let t=0;for(;t<a.length&&!(e.endTime<a[t].endTime);t++);a.splice(t,0,e)})}n=this._currentTime,this._currentTime=i,r&&r(this._currentTime-n)}}flush(e=20,t=!1,r){return t?this.flushPeriodic(r):this.flushNonPeriodic(e,r)}flushPeriodic(e){if(0===this._schedulerQueue.length)return 0;const t=this._currentTime;return this.tick(this._schedulerQueue[this._schedulerQueue.length-1].endTime-t,e),this._currentTime-t}flushNonPeriodic(t,r){const s=this._currentTime;let i=0,n=0;for(;this._schedulerQueue.length>0;){if(n++,n>t)throw new Error("flush failed after reaching the limit of "+t+" tasks. Does your code use a polling timeout?");if(0===this._schedulerQueue.filter(e=>!e.isPeriodic&&!e.isRequestAnimationFrame).length)break;const s=this._schedulerQueue.shift();if(i=this._currentTime,this._currentTime=s.endTime,r&&r(this._currentTime-i),!s.func.apply(e,s.args))break}return this._currentTime-s}}i.nextId=1;class n{constructor(t,r=!1,s){this.trackPendingRequestAnimationFrame=r,this.macroTaskOptions=s,this._scheduler=new i,this._microtasks=[],this._lastError=null,this._uncaughtPromiseErrors=Promise[Zone.__symbol__("uncaughtPromiseErrors")],this.pendingPeriodicTimers=[],this.pendingTimers=[],this.patchDateLocked=!1,this.properties={FakeAsyncTestZoneSpec:this},this.name="fakeAsyncTestZone for "+t,this.macroTaskOptions||(this.macroTaskOptions=e[Zone.__symbol__("FakeAsyncTestMacroTask")])}static assertInZone(){if(null==Zone.current.get("FakeAsyncTestZoneSpec"))throw new Error("The code should be running in the fakeAsync zone to call this function")}_fnAndFlush(t,r){return(...s)=>(t.apply(e,s),null===this._lastError?(null!=r.onSuccess&&r.onSuccess.apply(e),this.flushMicrotasks()):null!=r.onError&&r.onError.apply(e),null===this._lastError)}static _removeTimer(e,t){let r=e.indexOf(t);r>-1&&e.splice(r,1)}_dequeueTimer(e){return()=>{n._removeTimer(this.pendingTimers,e)}}_requeuePeriodicTimer(e,t,r,s){return()=>{-1!==this.pendingPeriodicTimers.indexOf(s)&&this._scheduler.scheduleFunction(e,t,{args:r,isPeriodic:!0,id:s,isRequeuePeriodic:!0})}}_dequeuePeriodicTimer(e){return()=>{n._removeTimer(this.pendingPeriodicTimers,e)}}_setTimeout(e,t,r,s=!0){let n=this._dequeueTimer(i.nextId),a=this._fnAndFlush(e,{onSuccess:n,onError:n}),c=this._scheduler.scheduleFunction(a,t,{args:r,isRequestAnimationFrame:!s});return s&&this.pendingTimers.push(c),c}_clearTimeout(e){n._removeTimer(this.pendingTimers,e),this._scheduler.removeScheduledFunctionWithId(e)}_setInterval(e,t,r){let s=i.nextId,n={onSuccess:null,onError:this._dequeuePeriodicTimer(s)},a=this._fnAndFlush(e,n);return n.onSuccess=this._requeuePeriodicTimer(a,t,r,s),this._scheduler.scheduleFunction(a,t,{args:r,isPeriodic:!0}),this.pendingPeriodicTimers.push(s),s}_clearInterval(e){n._removeTimer(this.pendingPeriodicTimers,e),this._scheduler.removeScheduledFunctionWithId(e)}_resetLastErrorAndThrow(){let e=this._lastError||this._uncaughtPromiseErrors[0];throw this._uncaughtPromiseErrors.length=0,this._lastError=null,e}getCurrentTime(){return this._scheduler.getCurrentTime()}getCurrentRealTime(){return this._scheduler.getCurrentRealTime()}setCurrentRealTime(e){this._scheduler.setCurrentRealTime(e)}static patchDate(){e[Zone.__symbol__("disableDatePatching")]||e.Date!==r&&(e.Date=r,r.prototype=t.prototype,n.checkTimerPatch())}static resetDate(){e.Date===r&&(e.Date=t)}static checkTimerPatch(){e.setTimeout!==s.setTimeout&&(e.setTimeout=s.setTimeout,e.clearTimeout=s.clearTimeout),e.setInterval!==s.setInterval&&(e.setInterval=s.setInterval,e.clearInterval=s.clearInterval)}lockDatePatch(){this.patchDateLocked=!0,n.patchDate()}unlockDatePatch(){this.patchDateLocked=!1,n.resetDate()}tick(e=0,t,r={processNewMacroTasksSynchronously:!0}){n.assertInZone(),this.flushMicrotasks(),this._scheduler.tick(e,t,r),null!==this._lastError&&this._resetLastErrorAndThrow()}flushMicrotasks(){for(n.assertInZone();this._microtasks.length>0;){let e=this._microtasks.shift();e.func.apply(e.target,e.args)}(()=>{(null!==this._lastError||this._uncaughtPromiseErrors.length)&&this._resetLastErrorAndThrow()})()}flush(e,t,r){n.assertInZone(),this.flushMicrotasks();const s=this._scheduler.flush(e,t,r);return null!==this._lastError&&this._resetLastErrorAndThrow(),s}onScheduleTask(e,t,r,s){switch(s.type){case"microTask":let t,i=s.data&&s.data.args;if(i){let e=s.data.cbIdx;"number"==typeof i.length&&i.length>e+1&&(t=Array.prototype.slice.call(i,e+1))}this._microtasks.push({func:s.invoke,args:t,target:s.data&&s.data.target});break;case"macroTask":switch(s.source){case"setTimeout":s.data.handleId=this._setTimeout(s.invoke,s.data.delay,Array.prototype.slice.call(s.data.args,2));break;case"setImmediate":s.data.handleId=this._setTimeout(s.invoke,0,Array.prototype.slice.call(s.data.args,1));break;case"setInterval":s.data.handleId=this._setInterval(s.invoke,s.data.delay,Array.prototype.slice.call(s.data.args,2));break;case"XMLHttpRequest.send":throw new Error("Cannot make XHRs from within a fake async test. Request URL: "+s.data.url);case"requestAnimationFrame":case"webkitRequestAnimationFrame":case"mozRequestAnimationFrame":s.data.handleId=this._setTimeout(s.invoke,16,s.data.args,this.trackPendingRequestAnimationFrame);break;default:const e=this.findMacroTaskOption(s);if(e){const t=s.data&&s.data.args,r=t&&t.length>1?t[1]:0;let i=e.callbackArgs?e.callbackArgs:t;e.isPeriodic?(s.data.handleId=this._setInterval(s.invoke,r,i),s.data.isPeriodic=!0):s.data.handleId=this._setTimeout(s.invoke,r,i);break}throw new Error("Unknown macroTask scheduled in fake async test: "+s.source)}break;case"eventTask":s=e.scheduleTask(r,s)}return s}onCancelTask(e,t,r,s){switch(s.source){case"setTimeout":case"requestAnimationFrame":case"webkitRequestAnimationFrame":case"mozRequestAnimationFrame":return this._clearTimeout(s.data.handleId);case"setInterval":return this._clearInterval(s.data.handleId);default:const t=this.findMacroTaskOption(s);if(t){const e=s.data.handleId;return t.isPeriodic?this._clearInterval(e):this._clearTimeout(e)}return e.cancelTask(r,s)}}onInvoke(e,t,r,s,i,a,c){try{return n.patchDate(),e.invoke(r,s,i,a,c)}finally{this.patchDateLocked||n.resetDate()}}findMacroTaskOption(e){if(!this.macroTaskOptions)return null;for(let t=0;t<this.macroTaskOptions.length;t++){const r=this.macroTaskOptions[t];if(r.source===e.source)return r}return null}onHandleError(e,t,r,s){return this._lastError=s,!1}}Zone.FakeAsyncTestZoneSpec=n}("object"==typeof window&&window||"object"==typeof self&&self||global),
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
Zone.__load_patch("fakeasync",(e,t,r)=>{const s=t&&t.FakeAsyncTestZoneSpec,i=t&&t.ProxyZoneSpec;let n=null;function a(){n&&n.unlockDatePatch(),n=null,i&&i.assertPresent().resetDelegate()}function c(){if(null==n&&(n=t.current.get("FakeAsyncTestZoneSpec"),null==n))throw new Error("The code should be running in the fakeAsync zone to call this function");return n}function o(){c().flushMicrotasks()}t[r.symbol("fakeAsyncTest")]={resetFakeAsyncZone:a,flushMicrotasks:o,discardPeriodicTasks:function u(){c().pendingPeriodicTimers.length=0},tick:function l(e=0,t=!1){c().tick(e,null,t)},flush:function h(e){return c().flush(e)},fakeAsync:function d(e){return function(...r){const c=i.assertPresent();if(t.current.get("FakeAsyncTestZoneSpec"))throw new Error("fakeAsync() calls can not be nested");try{if(!n){if(c.getDelegate()instanceof s)throw new Error("fakeAsync() calls can not be nested");n=new s}let t;const i=c.getDelegate();c.setDelegate(n),n.lockDatePatch();try{t=e.apply(this,r),o()}finally{c.setDelegate(i)}if(n.pendingPeriodicTimers.length>0)throw new Error(`${n.pendingPeriodicTimers.length} `+"periodic timer(s) still in the queue.");if(n.pendingTimers.length>0)throw new Error(`${n.pendingTimers.length} timer(s) still in the queue.`);return t}finally{a()}}}}})}));