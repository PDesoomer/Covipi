{"ast":null,"code":"import _classCallCheck from \"/home/dougair/Documents/WebDev/Angular/Covipi/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/dougair/Documents/WebDev/Angular/Covipi/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Pipe, NgModule } from '@angular/core';\nimport * as ɵngcc0 from '@angular/core';\n\nvar OrderPipe = /*#__PURE__*/function () {\n  function OrderPipe() {\n    _classCallCheck(this, OrderPipe);\n  }\n\n  _createClass(OrderPipe, [{\n    key: \"transform\",\n    value: function transform(value, expression, reverse) {\n      var isCaseInsensitive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var comparator = arguments.length > 4 ? arguments[4] : undefined;\n\n      if (!value) {\n        return value;\n      }\n\n      if (Array.isArray(expression)) {\n        return this.multiExpressionTransform(value, expression, reverse, isCaseInsensitive, comparator);\n      }\n\n      if (Array.isArray(value)) {\n        return this.sortArray(value.slice(), expression, reverse, isCaseInsensitive, comparator);\n      }\n\n      if (typeof value === \"object\") {\n        return this.transformObject(Object.assign({}, value), expression, reverse, isCaseInsensitive, comparator);\n      }\n\n      return value;\n    }\n    /**\n     * Sort array\n     *\n     * @param value\n     * @param expression\n     * @param reverse\n     * @param isCaseInsensitive\n     * @param comparator\n     * @returns {any[]}\n     */\n\n  }, {\n    key: \"sortArray\",\n    value: function sortArray(value, expression, reverse, isCaseInsensitive, comparator) {\n      var isDeepLink = expression && expression.indexOf(\".\") !== -1;\n\n      if (isDeepLink) {\n        expression = OrderPipe.parseExpression(expression);\n      }\n\n      var compareFn;\n\n      if (comparator && typeof comparator === \"function\") {\n        compareFn = comparator;\n      } else {\n        compareFn = isCaseInsensitive ? OrderPipe.caseInsensitiveSort : OrderPipe.defaultCompare;\n      }\n\n      var array = value.sort(function (a, b) {\n        if (!expression) {\n          return compareFn(a, b);\n        }\n\n        if (!isDeepLink) {\n          if (a && b) {\n            return compareFn(a[expression], b[expression]);\n          }\n\n          return compareFn(a, b);\n        }\n\n        return compareFn(OrderPipe.getValue(a, expression), OrderPipe.getValue(b, expression));\n      });\n\n      if (reverse) {\n        return array.reverse();\n      }\n\n      return array;\n    }\n    /**\n     * Transform Object\n     *\n     * @param value\n     * @param expression\n     * @param reverse\n     * @param isCaseInsensitive\n     * @param comparator\n     * @returns {any[]}\n     */\n\n  }, {\n    key: \"transformObject\",\n    value: function transformObject(value, expression, reverse, isCaseInsensitive, comparator) {\n      var parsedExpression = OrderPipe.parseExpression(expression);\n      var lastPredicate = parsedExpression.pop();\n      var oldValue = OrderPipe.getValue(value, parsedExpression);\n\n      if (!Array.isArray(oldValue)) {\n        parsedExpression.push(lastPredicate);\n        lastPredicate = null;\n        oldValue = OrderPipe.getValue(value, parsedExpression);\n      }\n\n      if (!oldValue) {\n        return value;\n      }\n\n      OrderPipe.setValue(value, this.transform(oldValue, lastPredicate, reverse, isCaseInsensitive), parsedExpression);\n      return value;\n    }\n    /**\n     * Apply multiple expressions\n     *\n     * @param value\n     * @param {any[]} expressions\n     * @param {boolean} reverse\n     * @param {boolean} isCaseInsensitive\n     * @param {Function} comparator\n     * @returns {any}\n     */\n\n  }, {\n    key: \"multiExpressionTransform\",\n    value: function multiExpressionTransform(value, expressions, reverse) {\n      var _this = this;\n\n      var isCaseInsensitive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var comparator = arguments.length > 4 ? arguments[4] : undefined;\n      return expressions.reverse().reduce(function (result, expression) {\n        return _this.transform(result, expression, reverse, isCaseInsensitive, comparator);\n      }, value);\n    }\n  }], [{\n    key: \"isString\",\n\n    /**\n     * Check if a value is a string\n     *\n     * @param value\n     */\n    value: function isString(value) {\n      return typeof value === \"string\" || value instanceof String;\n    }\n    /**\n     * Sorts values ignoring the case\n     *\n     * @param a\n     * @param b\n     */\n\n  }, {\n    key: \"caseInsensitiveSort\",\n    value: function caseInsensitiveSort(a, b) {\n      if (OrderPipe.isString(a) && OrderPipe.isString(b)) {\n        return a.localeCompare(b);\n      }\n\n      return OrderPipe.defaultCompare(a, b);\n    }\n    /**\n     * Default compare method\n     *\n     * @param a\n     * @param b\n     */\n\n  }, {\n    key: \"defaultCompare\",\n    value: function defaultCompare(a, b) {\n      if (a && a instanceof Date) {\n        a = a.getTime();\n      }\n\n      if (b && b instanceof Date) {\n        b = b.getTime();\n      }\n\n      if (a === b) {\n        return 0;\n      }\n\n      if (a == null) {\n        return 1;\n      }\n\n      if (b == null) {\n        return -1;\n      }\n\n      return a > b ? 1 : -1;\n    }\n    /**\n     * Parse expression, split into items\n     * @param expression\n     * @returns {string[]}\n     */\n\n  }, {\n    key: \"parseExpression\",\n    value: function parseExpression(expression) {\n      expression = expression.replace(/\\[(\\w+)\\]/g, \".$1\");\n      expression = expression.replace(/^\\./, \"\");\n      return expression.split(\".\");\n    }\n    /**\n     * Get value by expression\n     *\n     * @param object\n     * @param expression\n     * @returns {any}\n     */\n\n  }, {\n    key: \"getValue\",\n    value: function getValue(object, expression) {\n      for (var i = 0, n = expression.length; i < n; ++i) {\n        if (!object) {\n          return;\n        }\n\n        var k = expression[i];\n\n        if (!(k in object)) {\n          return;\n        }\n\n        if (typeof object[k] === \"function\") {\n          object = object[k]();\n        } else {\n          object = object[k];\n        }\n      }\n\n      return object;\n    }\n    /**\n     * Set value by expression\n     *\n     * @param object\n     * @param value\n     * @param expression\n     */\n\n  }, {\n    key: \"setValue\",\n    value: function setValue(object, value, expression) {\n      var i;\n\n      for (i = 0; i < expression.length - 1; i++) {\n        object = object[expression[i]];\n      }\n\n      object[expression[i]] = value;\n    }\n  }]);\n\n  return OrderPipe;\n}();\n\nOrderPipe.ɵfac = function OrderPipe_Factory(t) {\n  return new (t || OrderPipe)();\n};\n\nOrderPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({\n  name: \"orderBy\",\n  type: OrderPipe,\n  pure: false\n});\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(OrderPipe, [{\n    type: Pipe,\n    args: [{\n      name: \"orderBy\",\n      pure: false\n    }]\n  }], null, null);\n})();\n/**\n * Created by vadimdez on 20/01/2017.\n */\n\n\nvar OrderModule = function OrderModule() {\n  _classCallCheck(this, OrderModule);\n};\n\nOrderModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: OrderModule\n});\nOrderModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function OrderModule_Factory(t) {\n    return new (t || OrderModule)();\n  },\n  providers: [OrderPipe]\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(OrderModule, {\n    declarations: [OrderPipe],\n    exports: [OrderPipe]\n  });\n})();\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(OrderModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [OrderPipe],\n      exports: [OrderPipe],\n      providers: [OrderPipe]\n    }]\n  }], null, null);\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { OrderModule, OrderPipe };","map":{"version":3,"sources":["../../src/app/order-pipe/ngx-order.pipe.ts","../../src/app/order-pipe/ngx-order.module.ts","../../ngx-order-pipe.ts"],"names":[],"mappings":"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","sourcesContent":["import { Pipe, PipeTransform } from \"@angular/core\";\n\n@Pipe({\n  name: \"orderBy\",\n  pure: false,\n})\nexport class OrderPipe implements PipeTransform {\n  /**\n   * Check if a value is a string\n   *\n   * @param value\n   */\n  static isString(value: any) {\n    return typeof value === \"string\" || value instanceof String;\n  }\n\n  /**\n   * Sorts values ignoring the case\n   *\n   * @param a\n   * @param b\n   */\n  static caseInsensitiveSort(a: any, b: any) {\n    if (OrderPipe.isString(a) && OrderPipe.isString(b)) {\n      return a.localeCompare(b);\n    }\n    return OrderPipe.defaultCompare(a, b);\n  }\n\n  /**\n   * Default compare method\n   *\n   * @param a\n   * @param b\n   */\n  static defaultCompare(a: any, b: any) {\n    if (a && a instanceof Date) {\n      a = a.getTime();\n    }\n    if (b && b instanceof Date) {\n      b = b.getTime();\n    }\n\n    if (a === b) {\n      return 0;\n    }\n    if (a == null) {\n      return 1;\n    }\n    if (b == null) {\n      return -1;\n    }\n    return a > b ? 1 : -1;\n  }\n\n  /**\n   * Parse expression, split into items\n   * @param expression\n   * @returns {string[]}\n   */\n  static parseExpression(expression: string): string[] {\n    expression = expression.replace(/\\[(\\w+)\\]/g, \".$1\");\n    expression = expression.replace(/^\\./, \"\");\n    return expression.split(\".\");\n  }\n\n  /**\n   * Get value by expression\n   *\n   * @param object\n   * @param expression\n   * @returns {any}\n   */\n  static getValue(object: any, expression: string[]) {\n    for (let i = 0, n = expression.length; i < n; ++i) {\n      if (!object) {\n        return;\n      }\n      const k = expression[i];\n      if (!(k in object)) {\n        return;\n      }\n      if (typeof object[k] === \"function\") {\n        object = object[k]();\n      } else {\n        object = object[k];\n      }\n    }\n\n    return object;\n  }\n\n  /**\n   * Set value by expression\n   *\n   * @param object\n   * @param value\n   * @param expression\n   */\n  static setValue(object: any, value: any, expression: string[]) {\n    let i;\n    for (i = 0; i < expression.length - 1; i++) {\n      object = object[expression[i]];\n    }\n\n    object[expression[i]] = value;\n  }\n\n  transform(\n    value: any | any[],\n    expression?: any,\n    reverse?: boolean,\n    isCaseInsensitive: boolean = false,\n    comparator?: Function\n  ): any {\n    if (!value) {\n      return value;\n    }\n\n    if (Array.isArray(expression)) {\n      return this.multiExpressionTransform(\n        value,\n        expression,\n        reverse,\n        isCaseInsensitive,\n        comparator\n      );\n    }\n\n    if (Array.isArray(value)) {\n      return this.sortArray(\n        value.slice(),\n        expression,\n        reverse,\n        isCaseInsensitive,\n        comparator\n      );\n    }\n\n    if (typeof value === \"object\") {\n      return this.transformObject(\n        Object.assign({}, value),\n        expression,\n        reverse,\n        isCaseInsensitive,\n        comparator\n      );\n    }\n\n    return value;\n  }\n\n  /**\n   * Sort array\n   *\n   * @param value\n   * @param expression\n   * @param reverse\n   * @param isCaseInsensitive\n   * @param comparator\n   * @returns {any[]}\n   */\n  private sortArray(\n    value: any[],\n    expression?: any,\n    reverse?: boolean,\n    isCaseInsensitive?: boolean,\n    comparator?: Function\n  ): any[] {\n    const isDeepLink = expression && expression.indexOf(\".\") !== -1;\n\n    if (isDeepLink) {\n      expression = OrderPipe.parseExpression(expression);\n    }\n\n    let compareFn: Function;\n\n    if (comparator && typeof comparator === \"function\") {\n      compareFn = comparator;\n    } else {\n      compareFn = isCaseInsensitive\n        ? OrderPipe.caseInsensitiveSort\n        : OrderPipe.defaultCompare;\n    }\n\n    const array: any[] = value.sort((a: any, b: any): number => {\n      if (!expression) {\n        return compareFn(a, b);\n      }\n\n      if (!isDeepLink) {\n        if (a && b) {\n          return compareFn(a[expression], b[expression]);\n        }\n        return compareFn(a, b);\n      }\n\n      return compareFn(\n        OrderPipe.getValue(a, expression),\n        OrderPipe.getValue(b, expression)\n      );\n    });\n\n    if (reverse) {\n      return array.reverse();\n    }\n\n    return array;\n  }\n\n  /**\n   * Transform Object\n   *\n   * @param value\n   * @param expression\n   * @param reverse\n   * @param isCaseInsensitive\n   * @param comparator\n   * @returns {any[]}\n   */\n  private transformObject(\n    value: any | any[],\n    expression?: any,\n    reverse?: boolean,\n    isCaseInsensitive?: boolean,\n    comparator?: Function\n  ): any {\n    const parsedExpression = OrderPipe.parseExpression(expression);\n    let lastPredicate = parsedExpression.pop();\n    let oldValue = OrderPipe.getValue(value, parsedExpression);\n\n    if (!Array.isArray(oldValue)) {\n      parsedExpression.push(lastPredicate);\n      lastPredicate = null;\n      oldValue = OrderPipe.getValue(value, parsedExpression);\n    }\n\n    if (!oldValue) {\n      return value;\n    }\n\n    OrderPipe.setValue(\n      value,\n      this.transform(oldValue, lastPredicate, reverse, isCaseInsensitive),\n      parsedExpression\n    );\n    return value;\n  }\n\n  /**\n   * Apply multiple expressions\n   *\n   * @param value\n   * @param {any[]} expressions\n   * @param {boolean} reverse\n   * @param {boolean} isCaseInsensitive\n   * @param {Function} comparator\n   * @returns {any}\n   */\n  private multiExpressionTransform(\n    value: any,\n    expressions: any[],\n    reverse: boolean,\n    isCaseInsensitive: boolean = false,\n    comparator?: Function\n  ): any {\n    return expressions.reverse().reduce((result: any, expression: any) => {\n      return this.transform(\n        result,\n        expression,\n        reverse,\n        isCaseInsensitive,\n        comparator\n      );\n    }, value);\n  }\n}\n","/**\n * Created by vadimdez on 20/01/2017.\n */\nimport { NgModule } from '@angular/core';\nimport { OrderPipe } from './ngx-order.pipe';\n\n@NgModule({\n  declarations: [OrderPipe],\n  exports: [OrderPipe],\n  providers: [OrderPipe]\n})\nexport class OrderModule {}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"]},"metadata":{},"sourceType":"module"}