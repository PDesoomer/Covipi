{"ast":null,"code":"import _assertThisInitialized from \"/home/dougair/Documents/WebDev/Angular/Covipi/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/home/dougair/Documents/WebDev/Angular/Covipi/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/home/dougair/Documents/WebDev/Angular/Covipi/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/dougair/Documents/WebDev/Angular/Covipi/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/dougair/Documents/WebDev/Angular/Covipi/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/home/dougair/Documents/WebDev/Angular/Covipi/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/dougair/Documents/WebDev/Angular/Covipi/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { ElementRef, Directive, TemplateRef, ViewContainerRef, EventEmitter, ComponentFactoryResolver, Inject, Output, NgModule } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * @docs-private\n */\n\nimport * as Éµngcc0 from '@angular/core';\n\nfunction throwNullPortalError() {\n  throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * @docs-private\n */\n\n\nfunction throwPortalAlreadyAttachedError() {\n  throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * @docs-private\n */\n\n\nfunction throwPortalOutletAlreadyDisposedError() {\n  throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * @docs-private\n */\n\n\nfunction throwUnknownPortalTypeError() {\n  throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' + 'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * @docs-private\n */\n\n\nfunction throwNullPortalOutletError() {\n  throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * @docs-private\n */\n\n\nfunction throwNoPortalAttachedError() {\n  throw Error('Attempting to detach a portal that is not attached to a host');\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n */\n\n\nvar Portal = /*#__PURE__*/function () {\n  function Portal() {\n    _classCallCheck(this, Portal);\n  }\n\n  _createClass(Portal, [{\n    key: \"attach\",\n\n    /** Attach this portal to a host. */\n    value: function attach(host) {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (host == null) {\n          throwNullPortalOutletError();\n        }\n\n        if (host.hasAttached()) {\n          throwPortalAlreadyAttachedError();\n        }\n      }\n\n      this._attachedHost = host;\n      return host.attach(this);\n    }\n    /** Detach this portal from its host */\n\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      var host = this._attachedHost;\n\n      if (host != null) {\n        this._attachedHost = null;\n        host.detach();\n      } else if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        throwNoPortalAttachedError();\n      }\n    }\n    /** Whether this portal is attached to a host. */\n\n  }, {\n    key: \"setAttachedHost\",\n\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     */\n    value: function setAttachedHost(host) {\n      this._attachedHost = host;\n    }\n  }, {\n    key: \"isAttached\",\n    get: function get() {\n      return this._attachedHost != null;\n    }\n  }]);\n\n  return Portal;\n}();\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\n\n\nvar ComponentPortal = /*#__PURE__*/function (_Portal) {\n  _inherits(ComponentPortal, _Portal);\n\n  var _super = _createSuper(ComponentPortal);\n\n  function ComponentPortal(component, viewContainerRef, injector, componentFactoryResolver) {\n    var _this;\n\n    _classCallCheck(this, ComponentPortal);\n\n    _this = _super.call(this);\n    _this.component = component;\n    _this.viewContainerRef = viewContainerRef;\n    _this.injector = injector;\n    _this.componentFactoryResolver = componentFactoryResolver;\n    return _this;\n  }\n\n  return ComponentPortal;\n}(Portal);\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\n\n\nvar TemplatePortal = /*#__PURE__*/function (_Portal2) {\n  _inherits(TemplatePortal, _Portal2);\n\n  var _super2 = _createSuper(TemplatePortal);\n\n  function TemplatePortal(template, viewContainerRef, context) {\n    var _this2;\n\n    _classCallCheck(this, TemplatePortal);\n\n    _this2 = _super2.call(this);\n    _this2.templateRef = template;\n    _this2.viewContainerRef = viewContainerRef;\n    _this2.context = context;\n    return _this2;\n  }\n\n  _createClass(TemplatePortal, [{\n    key: \"attach\",\n\n    /**\n     * Attach the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     */\n    value: function attach(host) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;\n      this.context = context;\n      return _get(_getPrototypeOf(TemplatePortal.prototype), \"attach\", this).call(this, host);\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      this.context = undefined;\n      return _get(_getPrototypeOf(TemplatePortal.prototype), \"detach\", this).call(this);\n    }\n  }, {\n    key: \"origin\",\n    get: function get() {\n      return this.templateRef.elementRef;\n    }\n  }]);\n\n  return TemplatePortal;\n}(Portal);\n/**\n * A `DomPortal` is a portal whose DOM element will be taken from its current position\n * in the DOM and moved into a portal outlet, when it is attached. On detach, the content\n * will be restored to its original position.\n */\n\n\nvar DomPortal = /*#__PURE__*/function (_Portal3) {\n  _inherits(DomPortal, _Portal3);\n\n  var _super3 = _createSuper(DomPortal);\n\n  function DomPortal(element) {\n    var _this3;\n\n    _classCallCheck(this, DomPortal);\n\n    _this3 = _super3.call(this);\n    _this3.element = element instanceof ElementRef ? element.nativeElement : element;\n    return _this3;\n  }\n\n  return DomPortal;\n}(Portal);\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n */\n\n\nvar BasePortalOutlet = /*#__PURE__*/function () {\n  function BasePortalOutlet() {\n    _classCallCheck(this, BasePortalOutlet);\n\n    /** Whether this host has already been permanently disposed. */\n    this._isDisposed = false; // @breaking-change 10.0.0 `attachDomPortal` to become a required abstract method.\n\n    this.attachDomPortal = null;\n  }\n  /** Whether this host has an attached portal. */\n\n\n  _createClass(BasePortalOutlet, [{\n    key: \"hasAttached\",\n    value: function hasAttached() {\n      return !!this._attachedPortal;\n    }\n    /** Attaches a portal. */\n\n  }, {\n    key: \"attach\",\n    value: function attach(portal) {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (!portal) {\n          throwNullPortalError();\n        }\n\n        if (this.hasAttached()) {\n          throwPortalAlreadyAttachedError();\n        }\n\n        if (this._isDisposed) {\n          throwPortalOutletAlreadyDisposedError();\n        }\n      }\n\n      if (portal instanceof ComponentPortal) {\n        this._attachedPortal = portal;\n        return this.attachComponentPortal(portal);\n      } else if (portal instanceof TemplatePortal) {\n        this._attachedPortal = portal;\n        return this.attachTemplatePortal(portal); // @breaking-change 10.0.0 remove null check for `this.attachDomPortal`.\n      } else if (this.attachDomPortal && portal instanceof DomPortal) {\n        this._attachedPortal = portal;\n        return this.attachDomPortal(portal);\n      }\n\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        throwUnknownPortalTypeError();\n      }\n    }\n    /** Detaches a previously attached portal. */\n\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      if (this._attachedPortal) {\n        this._attachedPortal.setAttachedHost(null);\n\n        this._attachedPortal = null;\n      }\n\n      this._invokeDisposeFn();\n    }\n    /** Permanently dispose of this portal host. */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.hasAttached()) {\n        this.detach();\n      }\n\n      this._invokeDisposeFn();\n\n      this._isDisposed = true;\n    }\n    /** @docs-private */\n\n  }, {\n    key: \"setDisposeFn\",\n    value: function setDisposeFn(fn) {\n      this._disposeFn = fn;\n    }\n  }, {\n    key: \"_invokeDisposeFn\",\n    value: function _invokeDisposeFn() {\n      if (this._disposeFn) {\n        this._disposeFn();\n\n        this._disposeFn = null;\n      }\n    }\n  }]);\n\n  return BasePortalOutlet;\n}();\n/**\n * @deprecated Use `BasePortalOutlet` instead.\n * @breaking-change 9.0.0\n */\n\n\nvar BasePortalHost = /*#__PURE__*/function (_BasePortalOutlet) {\n  _inherits(BasePortalHost, _BasePortalOutlet);\n\n  var _super4 = _createSuper(BasePortalHost);\n\n  function BasePortalHost() {\n    _classCallCheck(this, BasePortalHost);\n\n    return _super4.apply(this, arguments);\n  }\n\n  return BasePortalHost;\n}(BasePortalOutlet);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\n\n\nvar DomPortalOutlet = /*#__PURE__*/function (_BasePortalOutlet2) {\n  _inherits(DomPortalOutlet, _BasePortalOutlet2);\n\n  var _super5 = _createSuper(DomPortalOutlet);\n\n  function DomPortalOutlet(\n  /** Element into which the content is projected. */\n  outletElement, _componentFactoryResolver, _appRef, _defaultInjector,\n  /**\n   * @deprecated `_document` Parameter to be made required.\n   * @breaking-change 10.0.0\n   */\n  _document) {\n    var _thisSuper, _this4;\n\n    _classCallCheck(this, DomPortalOutlet);\n\n    _this4 = _super5.call(this);\n    _this4.outletElement = outletElement;\n    _this4._componentFactoryResolver = _componentFactoryResolver;\n    _this4._appRef = _appRef;\n    _this4._defaultInjector = _defaultInjector;\n    /**\n     * Attaches a DOM portal by transferring its content into the outlet.\n     * @param portal Portal to be attached.\n     * @deprecated To be turned into a method.\n     * @breaking-change 10.0.0\n     */\n\n    _this4.attachDomPortal = function (portal) {\n      // @breaking-change 10.0.0 Remove check and error once the\n      // `_document` constructor parameter is required.\n      if (!_this4._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('Cannot attach DOM portal without _document constructor parameter');\n      }\n\n      var element = portal.element;\n\n      if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('DOM portal content must be attached to a parent node.');\n      } // Anchor used to save the element's previous position so\n      // that we can restore it when the portal is detached.\n\n\n      var anchorNode = _this4._document.createComment('dom-portal');\n\n      element.parentNode.insertBefore(anchorNode, element);\n\n      _this4.outletElement.appendChild(element);\n\n      _get((_thisSuper = _assertThisInitialized(_this4), _getPrototypeOf(DomPortalOutlet.prototype)), \"setDisposeFn\", _thisSuper).call(_thisSuper, function () {\n        // We can't use `replaceWith` here because IE doesn't support it.\n        if (anchorNode.parentNode) {\n          anchorNode.parentNode.replaceChild(element, anchorNode);\n        }\n      });\n    };\n\n    _this4._document = _document;\n    return _this4;\n  }\n  /**\n   * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n   * @param portal Portal to be attached\n   * @returns Reference to the created component.\n   */\n\n\n  _createClass(DomPortalOutlet, [{\n    key: \"attachComponentPortal\",\n    value: function attachComponentPortal(portal) {\n      var _this5 = this;\n\n      var resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n      var componentFactory = resolver.resolveComponentFactory(portal.component);\n      var componentRef; // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n      // for the component (in terms of Angular's component tree, not rendering).\n      // When the ViewContainerRef is missing, we use the factory to create the component directly\n      // and then manually attach the view to the application.\n\n      if (portal.viewContainerRef) {\n        componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector);\n        this.setDisposeFn(function () {\n          return componentRef.destroy();\n        });\n      } else {\n        componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n\n        this._appRef.attachView(componentRef.hostView);\n\n        this.setDisposeFn(function () {\n          _this5._appRef.detachView(componentRef.hostView);\n\n          componentRef.destroy();\n        });\n      } // At this point the component has been instantiated, so we move it to the location in the DOM\n      // where we want it to be rendered.\n\n\n      this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n      return componentRef;\n    }\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n\n  }, {\n    key: \"attachTemplatePortal\",\n    value: function attachTemplatePortal(portal) {\n      var _this6 = this;\n\n      var viewContainer = portal.viewContainerRef;\n      var viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context); // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n      // But for the DomPortalOutlet the view can be added everywhere in the DOM\n      // (e.g Overlay Container) To move the view to the specified host element. We just\n      // re-append the existing root nodes.\n\n      viewRef.rootNodes.forEach(function (rootNode) {\n        return _this6.outletElement.appendChild(rootNode);\n      }); // Note that we want to detect changes after the nodes have been moved so that\n      // any directives inside the portal that are looking at the DOM inside a lifecycle\n      // hook won't be invoked too early.\n\n      viewRef.detectChanges();\n      this.setDisposeFn(function () {\n        var index = viewContainer.indexOf(viewRef);\n\n        if (index !== -1) {\n          viewContainer.remove(index);\n        }\n      }); // TODO(jelbourn): Return locals from view.\n\n      return viewRef;\n    }\n    /**\n     * Clears out a portal from the DOM.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(DomPortalOutlet.prototype), \"dispose\", this).call(this);\n\n      if (this.outletElement.parentNode != null) {\n        this.outletElement.parentNode.removeChild(this.outletElement);\n      }\n    }\n    /** Gets the root HTMLElement for an instantiated component. */\n\n  }, {\n    key: \"_getComponentRootNode\",\n    value: function _getComponentRootNode(componentRef) {\n      return componentRef.hostView.rootNodes[0];\n    }\n  }]);\n\n  return DomPortalOutlet;\n}(BasePortalOutlet);\n/**\n * @deprecated Use `DomPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\n\n\nvar DomPortalHost = /*#__PURE__*/function (_DomPortalOutlet) {\n  _inherits(DomPortalHost, _DomPortalOutlet);\n\n  var _super6 = _createSuper(DomPortalHost);\n\n  function DomPortalHost() {\n    _classCallCheck(this, DomPortalHost);\n\n    return _super6.apply(this, arguments);\n  }\n\n  return DomPortalHost;\n}(DomPortalOutlet);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\n\n\nvar CdkPortal = /*#__PURE__*/function (_TemplatePortal) {\n  _inherits(CdkPortal, _TemplatePortal);\n\n  var _super7 = _createSuper(CdkPortal);\n\n  function CdkPortal(templateRef, viewContainerRef) {\n    _classCallCheck(this, CdkPortal);\n\n    return _super7.call(this, templateRef, viewContainerRef);\n  }\n\n  return CdkPortal;\n}(TemplatePortal);\n\nCdkPortal.Éµfac = function CdkPortal_Factory(t) {\n  return new (t || CdkPortal)(Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.TemplateRef), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.ViewContainerRef));\n};\n\nCdkPortal.Éµdir = Éµngcc0.ÉµÉµdefineDirective({\n  type: CdkPortal,\n  selectors: [[\"\", \"cdkPortal\", \"\"]],\n  exportAs: [\"cdkPortal\"],\n  features: [Éµngcc0.ÉµÉµInheritDefinitionFeature]\n});\n\nCdkPortal.ctorParameters = function () {\n  return [{\n    type: TemplateRef\n  }, {\n    type: ViewContainerRef\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  Éµngcc0.ÉµsetClassMetadata(CdkPortal, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkPortal]',\n      exportAs: 'cdkPortal'\n    }]\n  }], function () {\n    return [{\n      type: Éµngcc0.TemplateRef\n    }, {\n      type: Éµngcc0.ViewContainerRef\n    }];\n  }, null);\n})();\n/**\n * @deprecated Use `CdkPortal` instead.\n * @breaking-change 9.0.0\n */\n\n\nvar TemplatePortalDirective = /*#__PURE__*/function (_CdkPortal) {\n  _inherits(TemplatePortalDirective, _CdkPortal);\n\n  var _super8 = _createSuper(TemplatePortalDirective);\n\n  function TemplatePortalDirective() {\n    _classCallCheck(this, TemplatePortalDirective);\n\n    return _super8.apply(this, arguments);\n  }\n\n  return TemplatePortalDirective;\n}(CdkPortal);\n\nTemplatePortalDirective.Éµfac = function TemplatePortalDirective_Factory(t) {\n  return ÉµTemplatePortalDirective_BaseFactory(t || TemplatePortalDirective);\n};\n\nTemplatePortalDirective.Éµdir = Éµngcc0.ÉµÉµdefineDirective({\n  type: TemplatePortalDirective,\n  selectors: [[\"\", \"cdk-portal\", \"\"], [\"\", \"portal\", \"\"]],\n  exportAs: [\"cdkPortal\"],\n  features: [Éµngcc0.ÉµÉµProvidersFeature([{\n    provide: CdkPortal,\n    useExisting: TemplatePortalDirective\n  }]), Éµngcc0.ÉµÉµInheritDefinitionFeature]\n});\nvar ÉµTemplatePortalDirective_BaseFactory = /*@__PURE__*/Éµngcc0.ÉµÉµgetInheritedFactory(TemplatePortalDirective);\n/*@__PURE__*/\n\n(function () {\n  Éµngcc0.ÉµsetClassMetadata(TemplatePortalDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[cdk-portal], [portal]',\n      exportAs: 'cdkPortal',\n      providers: [{\n        provide: CdkPortal,\n        useExisting: TemplatePortalDirective\n      }]\n    }]\n  }], null, null);\n})();\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * `<ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>`\n */\n\n\nvar CdkPortalOutlet = /*#__PURE__*/function (_BasePortalOutlet3) {\n  _inherits(CdkPortalOutlet, _BasePortalOutlet3);\n\n  var _super9 = _createSuper(CdkPortalOutlet);\n\n  function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef,\n  /**\n   * @deprecated `_document` parameter to be made required.\n   * @breaking-change 9.0.0\n   */\n  _document) {\n    var _thisSuper2, _this7;\n\n    _classCallCheck(this, CdkPortalOutlet);\n\n    _this7 = _super9.call(this);\n    _this7._componentFactoryResolver = _componentFactoryResolver;\n    _this7._viewContainerRef = _viewContainerRef;\n    /** Whether the portal component is initialized. */\n\n    _this7._isInitialized = false;\n    /** Emits when a portal is attached to the outlet. */\n\n    _this7.attached = new EventEmitter();\n    /**\n     * Attaches the given DomPortal to this PortalHost by moving all of the portal content into it.\n     * @param portal Portal to be attached.\n     * @deprecated To be turned into a method.\n     * @breaking-change 10.0.0\n     */\n\n    _this7.attachDomPortal = function (portal) {\n      // @breaking-change 9.0.0 Remove check and error once the\n      // `_document` constructor parameter is required.\n      if (!_this7._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('Cannot attach DOM portal without _document constructor parameter');\n      }\n\n      var element = portal.element;\n\n      if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('DOM portal content must be attached to a parent node.');\n      } // Anchor used to save the element's previous position so\n      // that we can restore it when the portal is detached.\n\n\n      var anchorNode = _this7._document.createComment('dom-portal');\n\n      portal.setAttachedHost(_assertThisInitialized(_this7));\n      element.parentNode.insertBefore(anchorNode, element);\n\n      _this7._getRootNode().appendChild(element);\n\n      _get((_thisSuper2 = _assertThisInitialized(_this7), _getPrototypeOf(CdkPortalOutlet.prototype)), \"setDisposeFn\", _thisSuper2).call(_thisSuper2, function () {\n        if (anchorNode.parentNode) {\n          anchorNode.parentNode.replaceChild(element, anchorNode);\n        }\n      });\n    };\n\n    _this7._document = _document;\n    return _this7;\n  }\n  /** Portal associated with the Portal outlet. */\n\n\n  _createClass(CdkPortalOutlet, [{\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      this._isInitialized = true;\n    }\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"dispose\", this).call(this);\n\n      this._attachedPortal = null;\n      this._attachedRef = null;\n    }\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @param portal Portal to be attached to the portal outlet.\n     * @returns Reference to the created component.\n     */\n\n  }, {\n    key: \"attachComponentPortal\",\n    value: function attachComponentPortal(portal) {\n      portal.setAttachedHost(this); // If the portal specifies an origin, use that as the logical location of the component\n      // in the application tree. Otherwise use the location of this PortalOutlet.\n\n      var viewContainerRef = portal.viewContainerRef != null ? portal.viewContainerRef : this._viewContainerRef;\n      var resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n      var componentFactory = resolver.resolveComponentFactory(portal.component);\n      var ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector); // If we're using a view container that's different from the injected one (e.g. when the portal\n      // specifies its own) we need to move the component into the outlet, otherwise it'll be rendered\n      // inside of the alternate view container.\n\n      if (viewContainerRef !== this._viewContainerRef) {\n        this._getRootNode().appendChild(ref.hostView.rootNodes[0]);\n      }\n\n      _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"setDisposeFn\", this).call(this, function () {\n        return ref.destroy();\n      });\n\n      this._attachedPortal = portal;\n      this._attachedRef = ref;\n      this.attached.emit(ref);\n      return ref;\n    }\n    /**\n     * Attach the given TemplatePortal to this PortalHost as an embedded View.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n\n  }, {\n    key: \"attachTemplatePortal\",\n    value: function attachTemplatePortal(portal) {\n      var _this8 = this;\n\n      portal.setAttachedHost(this);\n\n      var viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n\n      _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"setDisposeFn\", this).call(this, function () {\n        return _this8._viewContainerRef.clear();\n      });\n\n      this._attachedPortal = portal;\n      this._attachedRef = viewRef;\n      this.attached.emit(viewRef);\n      return viewRef;\n    }\n    /** Gets the root node of the portal outlet. */\n\n  }, {\n    key: \"_getRootNode\",\n    value: function _getRootNode() {\n      var nativeElement = this._viewContainerRef.element.nativeElement; // The directive could be set on a template which will result in a comment\n      // node being the root. Use the comment's parent node if that is the case.\n\n      return nativeElement.nodeType === nativeElement.ELEMENT_NODE ? nativeElement : nativeElement.parentNode;\n    }\n  }, {\n    key: \"portal\",\n    get: function get() {\n      return this._attachedPortal;\n    },\n    set: function set(portal) {\n      // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n      // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n      // and attach a portal programmatically in the parent component. When Angular does the first CD\n      // round, it will fire the setter with empty string, causing the user's content to be cleared.\n      if (this.hasAttached() && !portal && !this._isInitialized) {\n        return;\n      }\n\n      if (this.hasAttached()) {\n        _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"detach\", this).call(this);\n      }\n\n      if (portal) {\n        _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"attach\", this).call(this, portal);\n      }\n\n      this._attachedPortal = portal;\n    }\n    /** Component or view reference that is attached to the portal. */\n\n  }, {\n    key: \"attachedRef\",\n    get: function get() {\n      return this._attachedRef;\n    }\n  }]);\n\n  return CdkPortalOutlet;\n}(BasePortalOutlet);\n\nCdkPortalOutlet.Éµfac = function CdkPortalOutlet_Factory(t) {\n  return new (t || CdkPortalOutlet)(Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.ComponentFactoryResolver), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.ViewContainerRef), Éµngcc0.ÉµÉµdirectiveInject(DOCUMENT));\n};\n\nCdkPortalOutlet.Éµdir = Éµngcc0.ÉµÉµdefineDirective({\n  type: CdkPortalOutlet,\n  selectors: [[\"\", \"cdkPortalOutlet\", \"\"]],\n  inputs: {\n    portal: [\"cdkPortalOutlet\", \"portal\"]\n  },\n  outputs: {\n    attached: \"attached\"\n  },\n  exportAs: [\"cdkPortalOutlet\"],\n  features: [Éµngcc0.ÉµÉµInheritDefinitionFeature]\n});\n\nCdkPortalOutlet.ctorParameters = function () {\n  return [{\n    type: ComponentFactoryResolver\n  }, {\n    type: ViewContainerRef\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }];\n};\n\nCdkPortalOutlet.propDecorators = {\n  attached: [{\n    type: Output\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  Éµngcc0.ÉµsetClassMetadata(CdkPortalOutlet, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkPortalOutlet]',\n      exportAs: 'cdkPortalOutlet',\n      inputs: ['portal: cdkPortalOutlet']\n    }]\n  }], function () {\n    return [{\n      type: Éµngcc0.ComponentFactoryResolver\n    }, {\n      type: Éµngcc0.ViewContainerRef\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, {\n    attached: [{\n      type: Output\n    }]\n  });\n})();\n/**\n * @deprecated Use `CdkPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\n\n\nvar PortalHostDirective = /*#__PURE__*/function (_CdkPortalOutlet) {\n  _inherits(PortalHostDirective, _CdkPortalOutlet);\n\n  var _super10 = _createSuper(PortalHostDirective);\n\n  function PortalHostDirective() {\n    _classCallCheck(this, PortalHostDirective);\n\n    return _super10.apply(this, arguments);\n  }\n\n  return PortalHostDirective;\n}(CdkPortalOutlet);\n\nPortalHostDirective.Éµfac = function PortalHostDirective_Factory(t) {\n  return ÉµPortalHostDirective_BaseFactory(t || PortalHostDirective);\n};\n\nPortalHostDirective.Éµdir = Éµngcc0.ÉµÉµdefineDirective({\n  type: PortalHostDirective,\n  selectors: [[\"\", \"cdkPortalHost\", \"\"], [\"\", \"portalHost\", \"\"]],\n  inputs: {\n    portal: [\"cdkPortalHost\", \"portal\"]\n  },\n  exportAs: [\"cdkPortalHost\"],\n  features: [Éµngcc0.ÉµÉµProvidersFeature([{\n    provide: CdkPortalOutlet,\n    useExisting: PortalHostDirective\n  }]), Éµngcc0.ÉµÉµInheritDefinitionFeature]\n});\nvar ÉµPortalHostDirective_BaseFactory = /*@__PURE__*/Éµngcc0.ÉµÉµgetInheritedFactory(PortalHostDirective);\n/*@__PURE__*/\n\n(function () {\n  Éµngcc0.ÉµsetClassMetadata(PortalHostDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkPortalHost], [portalHost]',\n      exportAs: 'cdkPortalHost',\n      inputs: ['portal: cdkPortalHost'],\n      providers: [{\n        provide: CdkPortalOutlet,\n        useExisting: PortalHostDirective\n      }]\n    }]\n  }], null, null);\n})();\n\nvar PortalModule = function PortalModule() {\n  _classCallCheck(this, PortalModule);\n};\n\nPortalModule.Éµmod = Éµngcc0.ÉµÉµdefineNgModule({\n  type: PortalModule\n});\nPortalModule.Éµinj = Éµngcc0.ÉµÉµdefineInjector({\n  factory: function PortalModule_Factory(t) {\n    return new (t || PortalModule)();\n  }\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && Éµngcc0.ÉµÉµsetNgModuleScope(PortalModule, {\n    declarations: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],\n    exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective]\n  });\n})();\n/*@__PURE__*/\n\n\n(function () {\n  Éµngcc0.ÉµsetClassMetadata(PortalModule, [{\n    type: NgModule,\n    args: [{\n      exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],\n      declarations: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective]\n    }]\n  }], null, null);\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * @docs-private\n * @deprecated Use `Injector.create` instead.\n * @breaking-change 11.0.0\n */\n\n\nvar PortalInjector = /*#__PURE__*/function () {\n  function PortalInjector(_parentInjector, _customTokens) {\n    _classCallCheck(this, PortalInjector);\n\n    this._parentInjector = _parentInjector;\n    this._customTokens = _customTokens;\n  }\n\n  _createClass(PortalInjector, [{\n    key: \"get\",\n    value: function get(token, notFoundValue) {\n      var value = this._customTokens.get(token);\n\n      if (typeof value !== 'undefined') {\n        return value;\n      }\n\n      return this._parentInjector.get(token, notFoundValue);\n    }\n  }]);\n\n  return PortalInjector;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { BasePortalHost, BasePortalOutlet, CdkPortal, CdkPortalOutlet, ComponentPortal, DomPortal, DomPortalHost, DomPortalOutlet, Portal, PortalHostDirective, PortalInjector, PortalModule, TemplatePortal, TemplatePortalDirective };","map":{"version":3,"sources":["../../../../../../src/cdk/portal/portal-errors.ts","../../../../../../src/cdk/portal/portal.ts","../../../../../../src/cdk/portal/dom-portal-outlet.ts","../../../../../../src/cdk/portal/portal-directives.ts","../../../../../../src/cdk/portal/portal-injector.ts","../../../../../../src/cdk/portal/public-api.ts","../../../../../../src/cdk/portal/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * @docs-private\n */\nexport function throwNullPortalError() {\n  throw Error('Must provide a portal to attach');\n}\n\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * @docs-private\n */\nexport function throwPortalAlreadyAttachedError() {\n  throw Error('Host already has a portal attached');\n}\n\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * @docs-private\n */\nexport function throwPortalOutletAlreadyDisposedError() {\n  throw Error('This PortalOutlet has already been disposed');\n}\n\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * @docs-private\n */\nexport function throwUnknownPortalTypeError() {\n  throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n              'a ComponentPortal or a TemplatePortal.');\n}\n\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * @docs-private\n */\nexport function throwNullPortalOutletError() {\n  throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * @docs-private\n */\nexport function throwNoPortalAttachedError() {\n  throw Error('Attempting to detach a portal that is not attached to a host');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n    TemplateRef,\n    ViewContainerRef,\n    ElementRef,\n    ComponentRef,\n    EmbeddedViewRef,\n    Injector,\n    ComponentFactoryResolver,\n} from '@angular/core';\nimport {\n    throwNullPortalOutletError,\n    throwPortalAlreadyAttachedError,\n    throwNoPortalAttachedError,\n    throwNullPortalError,\n    throwPortalOutletAlreadyDisposedError,\n    throwUnknownPortalTypeError\n} from './portal-errors';\n\n/** Interface that can be used to generically type a class. */\nexport interface ComponentType<T> {\n  new (...args: any[]): T;\n}\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n */\nexport abstract class Portal<T> {\n  private _attachedHost: PortalOutlet | null;\n\n  /** Attach this portal to a host. */\n  attach(host: PortalOutlet): T {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (host == null) {\n        throwNullPortalOutletError();\n      }\n\n      if (host.hasAttached()) {\n        throwPortalAlreadyAttachedError();\n      }\n    }\n\n    this._attachedHost = host;\n    return <T> host.attach(this);\n  }\n\n  /** Detach this portal from its host */\n  detach(): void {\n    let host = this._attachedHost;\n\n    if (host != null) {\n      this._attachedHost = null;\n      host.detach();\n    } else if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throwNoPortalAttachedError();\n    }\n  }\n\n  /** Whether this portal is attached to a host. */\n  get isAttached(): boolean {\n    return this._attachedHost != null;\n  }\n\n  /**\n   * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n   * the PortalOutlet when it is performing an `attach()` or `detach()`.\n   */\n  setAttachedHost(host: PortalOutlet | null) {\n    this._attachedHost = host;\n  }\n}\n\n\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nexport class ComponentPortal<T> extends Portal<ComponentRef<T>> {\n  /** The type of the component that will be instantiated for attachment. */\n  component: ComponentType<T>;\n\n  /**\n   * [Optional] Where the attached component should live in Angular's *logical* component tree.\n   * This is different from where the component *renders*, which is determined by the PortalOutlet.\n   * The origin is necessary when the host is outside of the Angular application context.\n   */\n  viewContainerRef?: ViewContainerRef | null;\n\n  /** [Optional] Injector used for the instantiation of the component. */\n  injector?: Injector | null;\n\n  /**\n   * Alternate `ComponentFactoryResolver` to use when resolving the associated component.\n   * Defaults to using the resolver from the outlet that the portal is attached to.\n   */\n  componentFactoryResolver?: ComponentFactoryResolver | null;\n\n  constructor(\n      component: ComponentType<T>,\n      viewContainerRef?: ViewContainerRef | null,\n      injector?: Injector | null,\n      componentFactoryResolver?: ComponentFactoryResolver | null) {\n    super();\n    this.component = component;\n    this.viewContainerRef = viewContainerRef;\n    this.injector = injector;\n    this.componentFactoryResolver = componentFactoryResolver;\n  }\n}\n\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nexport class TemplatePortal<C = any> extends Portal<EmbeddedViewRef<C>> {\n  /** The embedded template that will be used to instantiate an embedded View in the host. */\n  templateRef: TemplateRef<C>;\n\n  /** Reference to the ViewContainer into which the template will be stamped out. */\n  viewContainerRef: ViewContainerRef;\n\n  /** Contextual data to be passed in to the embedded view. */\n  context: C | undefined;\n\n  constructor(template: TemplateRef<C>, viewContainerRef: ViewContainerRef, context?: C) {\n    super();\n    this.templateRef = template;\n    this.viewContainerRef = viewContainerRef;\n    this.context = context;\n  }\n\n  get origin(): ElementRef {\n    return this.templateRef.elementRef;\n  }\n\n  /**\n   * Attach the portal to the provided `PortalOutlet`.\n   * When a context is provided it will override the `context` property of the `TemplatePortal`\n   * instance.\n   */\n  attach(host: PortalOutlet, context: C | undefined = this.context): EmbeddedViewRef<C> {\n    this.context = context;\n    return super.attach(host);\n  }\n\n  detach(): void {\n    this.context = undefined;\n    return super.detach();\n  }\n}\n\n/**\n * A `DomPortal` is a portal whose DOM element will be taken from its current position\n * in the DOM and moved into a portal outlet, when it is attached. On detach, the content\n * will be restored to its original position.\n */\nexport class DomPortal<T = HTMLElement> extends Portal<T> {\n  /** DOM node hosting the portal's content. */\n  readonly element: T;\n\n  constructor(element: T | ElementRef<T>) {\n    super();\n    this.element = element instanceof ElementRef ? element.nativeElement : element;\n  }\n}\n\n\n/** A `PortalOutlet` is an space that can contain a single `Portal`. */\nexport interface PortalOutlet {\n  /** Attaches a portal to this outlet. */\n  attach(portal: Portal<any>): any;\n\n  /** Detaches the currently attached portal from this outlet. */\n  detach(): any;\n\n  /** Performs cleanup before the outlet is destroyed. */\n  dispose(): void;\n\n  /** Whether there is currently a portal attached to this outlet. */\n  hasAttached(): boolean;\n}\n\n/**\n * @deprecated Use `PortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nexport type PortalHost = PortalOutlet;\n\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n */\nexport abstract class BasePortalOutlet implements PortalOutlet {\n  /** The portal currently attached to the host. */\n  protected _attachedPortal: Portal<any> | null;\n\n  /** A function that will permanently dispose this host. */\n  private _disposeFn: (() => void) | null;\n\n  /** Whether this host has already been permanently disposed. */\n  private _isDisposed: boolean = false;\n\n  /** Whether this host has an attached portal. */\n  hasAttached(): boolean {\n    return !!this._attachedPortal;\n  }\n\n  attach<T>(portal: ComponentPortal<T>): ComponentRef<T>;\n  attach<T>(portal: TemplatePortal<T>): EmbeddedViewRef<T>;\n  attach(portal: any): any;\n\n  /** Attaches a portal. */\n  attach(portal: Portal<any>): any {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!portal) {\n        throwNullPortalError();\n      }\n\n      if (this.hasAttached()) {\n        throwPortalAlreadyAttachedError();\n      }\n\n      if (this._isDisposed) {\n        throwPortalOutletAlreadyDisposedError();\n      }\n    }\n\n    if (portal instanceof ComponentPortal) {\n      this._attachedPortal = portal;\n      return this.attachComponentPortal(portal);\n    } else if (portal instanceof TemplatePortal) {\n      this._attachedPortal = portal;\n      return this.attachTemplatePortal(portal);\n      // @breaking-change 10.0.0 remove null check for `this.attachDomPortal`.\n    } else if (this.attachDomPortal && portal instanceof DomPortal) {\n      this._attachedPortal = portal;\n      return this.attachDomPortal(portal);\n    }\n\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throwUnknownPortalTypeError();\n    }\n  }\n\n  abstract attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T>;\n\n  abstract attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C>;\n\n  // @breaking-change 10.0.0 `attachDomPortal` to become a required abstract method.\n  readonly attachDomPortal: null | ((portal: DomPortal) => any) = null;\n\n  /** Detaches a previously attached portal. */\n  detach(): void {\n    if (this._attachedPortal) {\n      this._attachedPortal.setAttachedHost(null);\n      this._attachedPortal = null;\n    }\n\n    this._invokeDisposeFn();\n  }\n\n  /** Permanently dispose of this portal host. */\n  dispose(): void {\n    if (this.hasAttached()) {\n      this.detach();\n    }\n\n    this._invokeDisposeFn();\n    this._isDisposed = true;\n  }\n\n  /** @docs-private */\n  setDisposeFn(fn: () => void) {\n    this._disposeFn = fn;\n  }\n\n  private _invokeDisposeFn() {\n    if (this._disposeFn) {\n      this._disposeFn();\n      this._disposeFn = null;\n    }\n  }\n}\n\n/**\n * @deprecated Use `BasePortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nexport abstract class BasePortalHost extends BasePortalOutlet {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ComponentFactoryResolver,\n  ComponentRef,\n  EmbeddedViewRef,\n  ApplicationRef,\n  Injector,\n} from '@angular/core';\nimport {BasePortalOutlet, ComponentPortal, TemplatePortal, DomPortal} from './portal';\n\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nexport class DomPortalOutlet extends BasePortalOutlet {\n  private _document: Document;\n\n  constructor(\n      /** Element into which the content is projected. */\n      public outletElement: Element,\n      private _componentFactoryResolver: ComponentFactoryResolver,\n      private _appRef: ApplicationRef,\n      private _defaultInjector: Injector,\n\n      /**\n       * @deprecated `_document` Parameter to be made required.\n       * @breaking-change 10.0.0\n       */\n      _document?: any) {\n    super();\n    this._document = _document;\n  }\n\n  /**\n   * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n   * @param portal Portal to be attached\n   * @returns Reference to the created component.\n   */\n  attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n    const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n    const componentFactory = resolver.resolveComponentFactory(portal.component);\n    let componentRef: ComponentRef<T>;\n\n    // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n    // for the component (in terms of Angular's component tree, not rendering).\n    // When the ViewContainerRef is missing, we use the factory to create the component directly\n    // and then manually attach the view to the application.\n    if (portal.viewContainerRef) {\n      componentRef = portal.viewContainerRef.createComponent(\n          componentFactory,\n          portal.viewContainerRef.length,\n          portal.injector || portal.viewContainerRef.injector);\n\n      this.setDisposeFn(() => componentRef.destroy());\n    } else {\n      componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n      this._appRef.attachView(componentRef.hostView);\n      this.setDisposeFn(() => {\n        this._appRef.detachView(componentRef.hostView);\n        componentRef.destroy();\n      });\n    }\n    // At this point the component has been instantiated, so we move it to the location in the DOM\n    // where we want it to be rendered.\n    this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n\n    return componentRef;\n  }\n\n  /**\n   * Attaches a template portal to the DOM as an embedded view.\n   * @param portal Portal to be attached.\n   * @returns Reference to the created embedded view.\n   */\n  attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C> {\n    let viewContainer = portal.viewContainerRef;\n    let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n\n    // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n    // But for the DomPortalOutlet the view can be added everywhere in the DOM\n    // (e.g Overlay Container) To move the view to the specified host element. We just\n    // re-append the existing root nodes.\n    viewRef.rootNodes.forEach(rootNode => this.outletElement.appendChild(rootNode));\n\n    // Note that we want to detect changes after the nodes have been moved so that\n    // any directives inside the portal that are looking at the DOM inside a lifecycle\n    // hook won't be invoked too early.\n    viewRef.detectChanges();\n\n    this.setDisposeFn((() => {\n      let index = viewContainer.indexOf(viewRef);\n      if (index !== -1) {\n        viewContainer.remove(index);\n      }\n    }));\n\n    // TODO(jelbourn): Return locals from view.\n    return viewRef;\n  }\n\n  /**\n   * Attaches a DOM portal by transferring its content into the outlet.\n   * @param portal Portal to be attached.\n   * @deprecated To be turned into a method.\n   * @breaking-change 10.0.0\n   */\n  attachDomPortal = (portal: DomPortal) => {\n    // @breaking-change 10.0.0 Remove check and error once the\n    // `_document` constructor parameter is required.\n    if (!this._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('Cannot attach DOM portal without _document constructor parameter');\n    }\n\n    const element = portal.element;\n    if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('DOM portal content must be attached to a parent node.');\n    }\n\n    // Anchor used to save the element's previous position so\n    // that we can restore it when the portal is detached.\n    const anchorNode = this._document.createComment('dom-portal');\n\n    element.parentNode!.insertBefore(anchorNode, element);\n    this.outletElement.appendChild(element);\n\n    super.setDisposeFn(() => {\n      // We can't use `replaceWith` here because IE doesn't support it.\n      if (anchorNode.parentNode) {\n        anchorNode.parentNode.replaceChild(element, anchorNode);\n      }\n    });\n  }\n\n  /**\n   * Clears out a portal from the DOM.\n   */\n  dispose(): void {\n    super.dispose();\n    if (this.outletElement.parentNode != null) {\n      this.outletElement.parentNode.removeChild(this.outletElement);\n    }\n  }\n\n  /** Gets the root HTMLElement for an instantiated component. */\n  private _getComponentRootNode(componentRef: ComponentRef<any>): HTMLElement {\n    return (componentRef.hostView as EmbeddedViewRef<any>).rootNodes[0] as HTMLElement;\n  }\n}\n\n/**\n * @deprecated Use `DomPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nexport class DomPortalHost extends DomPortalOutlet {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ComponentFactoryResolver,\n  ComponentRef,\n  Directive,\n  EmbeddedViewRef,\n  EventEmitter,\n  NgModule,\n  OnDestroy,\n  OnInit,\n  Output,\n  TemplateRef,\n  ViewContainerRef,\n  Inject,\n} from '@angular/core';\nimport {DOCUMENT} from '@angular/common';\nimport {BasePortalOutlet, ComponentPortal, Portal, TemplatePortal, DomPortal} from './portal';\n\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\n@Directive({\n  selector: '[cdkPortal]',\n  exportAs: 'cdkPortal',\n})\nexport class CdkPortal extends TemplatePortal {\n  constructor(templateRef: TemplateRef<any>, viewContainerRef: ViewContainerRef) {\n    super(templateRef, viewContainerRef);\n  }\n}\n\n/**\n * @deprecated Use `CdkPortal` instead.\n * @breaking-change 9.0.0\n */\n@Directive({\n  selector: '[cdk-portal], [portal]',\n  exportAs: 'cdkPortal',\n  providers: [{\n    provide: CdkPortal,\n    useExisting: TemplatePortalDirective\n  }]\n})\nexport class TemplatePortalDirective extends CdkPortal {}\n\n/**\n * Possible attached references to the CdkPortalOutlet.\n */\nexport type CdkPortalOutletAttachedRef = ComponentRef<any> | EmbeddedViewRef<any> | null;\n\n\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * `<ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>`\n */\n@Directive({\n  selector: '[cdkPortalOutlet]',\n  exportAs: 'cdkPortalOutlet',\n  inputs: ['portal: cdkPortalOutlet']\n})\nexport class CdkPortalOutlet extends BasePortalOutlet implements OnInit, OnDestroy {\n  private _document: Document;\n\n  /** Whether the portal component is initialized. */\n  private _isInitialized = false;\n\n  /** Reference to the currently-attached component/view ref. */\n  private _attachedRef: CdkPortalOutletAttachedRef;\n\n  constructor(\n      private _componentFactoryResolver: ComponentFactoryResolver,\n      private _viewContainerRef: ViewContainerRef,\n\n      /**\n       * @deprecated `_document` parameter to be made required.\n       * @breaking-change 9.0.0\n       */\n      @Inject(DOCUMENT) _document?: any) {\n    super();\n    this._document = _document;\n  }\n\n  /** Portal associated with the Portal outlet. */\n  get portal(): Portal<any> | null {\n    return this._attachedPortal;\n  }\n\n  set portal(portal: Portal<any> | null) {\n    // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n    // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n    // and attach a portal programmatically in the parent component. When Angular does the first CD\n    // round, it will fire the setter with empty string, causing the user's content to be cleared.\n    if (this.hasAttached() && !portal && !this._isInitialized) {\n      return;\n    }\n\n    if (this.hasAttached()) {\n      super.detach();\n    }\n\n    if (portal) {\n      super.attach(portal);\n    }\n\n    this._attachedPortal = portal;\n  }\n\n  /** Emits when a portal is attached to the outlet. */\n  @Output() attached: EventEmitter<CdkPortalOutletAttachedRef> =\n      new EventEmitter<CdkPortalOutletAttachedRef>();\n\n  /** Component or view reference that is attached to the portal. */\n  get attachedRef(): CdkPortalOutletAttachedRef {\n    return this._attachedRef;\n  }\n\n  ngOnInit() {\n    this._isInitialized = true;\n  }\n\n  ngOnDestroy() {\n    super.dispose();\n    this._attachedPortal = null;\n    this._attachedRef = null;\n  }\n\n  /**\n   * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n   *\n   * @param portal Portal to be attached to the portal outlet.\n   * @returns Reference to the created component.\n   */\n  attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n    portal.setAttachedHost(this);\n\n    // If the portal specifies an origin, use that as the logical location of the component\n    // in the application tree. Otherwise use the location of this PortalOutlet.\n    const viewContainerRef = portal.viewContainerRef != null ?\n        portal.viewContainerRef :\n        this._viewContainerRef;\n\n    const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n    const componentFactory = resolver.resolveComponentFactory(portal.component);\n    const ref = viewContainerRef.createComponent(\n        componentFactory, viewContainerRef.length,\n        portal.injector || viewContainerRef.injector);\n\n    // If we're using a view container that's different from the injected one (e.g. when the portal\n    // specifies its own) we need to move the component into the outlet, otherwise it'll be rendered\n    // inside of the alternate view container.\n    if (viewContainerRef !== this._viewContainerRef) {\n      this._getRootNode().appendChild((ref.hostView as EmbeddedViewRef<any>).rootNodes[0]);\n    }\n\n    super.setDisposeFn(() => ref.destroy());\n    this._attachedPortal = portal;\n    this._attachedRef = ref;\n    this.attached.emit(ref);\n\n    return ref;\n  }\n\n  /**\n   * Attach the given TemplatePortal to this PortalHost as an embedded View.\n   * @param portal Portal to be attached.\n   * @returns Reference to the created embedded view.\n   */\n  attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C> {\n    portal.setAttachedHost(this);\n    const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n    super.setDisposeFn(() => this._viewContainerRef.clear());\n\n    this._attachedPortal = portal;\n    this._attachedRef = viewRef;\n    this.attached.emit(viewRef);\n\n    return viewRef;\n  }\n\n  /**\n   * Attaches the given DomPortal to this PortalHost by moving all of the portal content into it.\n   * @param portal Portal to be attached.\n   * @deprecated To be turned into a method.\n   * @breaking-change 10.0.0\n   */\n  attachDomPortal = (portal: DomPortal) => {\n    // @breaking-change 9.0.0 Remove check and error once the\n    // `_document` constructor parameter is required.\n    if (!this._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('Cannot attach DOM portal without _document constructor parameter');\n    }\n\n    const element = portal.element;\n    if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('DOM portal content must be attached to a parent node.');\n    }\n\n    // Anchor used to save the element's previous position so\n    // that we can restore it when the portal is detached.\n    const anchorNode = this._document.createComment('dom-portal');\n\n    portal.setAttachedHost(this);\n    element.parentNode!.insertBefore(anchorNode, element);\n    this._getRootNode().appendChild(element);\n\n    super.setDisposeFn(() => {\n      if (anchorNode.parentNode) {\n        anchorNode.parentNode!.replaceChild(element, anchorNode);\n      }\n    });\n  }\n\n  /** Gets the root node of the portal outlet. */\n  private _getRootNode(): HTMLElement {\n    const nativeElement: Node = this._viewContainerRef.element.nativeElement;\n\n    // The directive could be set on a template which will result in a comment\n    // node being the root. Use the comment's parent node if that is the case.\n    return (nativeElement.nodeType === nativeElement.ELEMENT_NODE ?\n           nativeElement : nativeElement.parentNode!) as HTMLElement;\n  }\n\n  static ngAcceptInputType_portal: Portal<any> | null | undefined | '';\n}\n\n/**\n * @deprecated Use `CdkPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\n@Directive({\n  selector: '[cdkPortalHost], [portalHost]',\n  exportAs: 'cdkPortalHost',\n  inputs: ['portal: cdkPortalHost'],\n  providers: [{\n    provide: CdkPortalOutlet,\n    useExisting: PortalHostDirective\n  }]\n})\nexport class PortalHostDirective extends CdkPortalOutlet {}\n\n\n@NgModule({\n  exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],\n  declarations: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],\n})\nexport class PortalModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '@angular/core';\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * @docs-private\n * @deprecated Use `Injector.create` instead.\n * @breaking-change 11.0.0\n */\nexport class PortalInjector implements Injector {\n  constructor(\n    private _parentInjector: Injector,\n    private _customTokens: WeakMap<any, any>) { }\n\n  get(token: any, notFoundValue?: any): any {\n    const value = this._customTokens.get(token);\n\n    if (typeof value !== 'undefined') {\n      return value;\n    }\n\n    return this._parentInjector.get<any>(token, notFoundValue);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport * from './portal';\nexport * from './dom-portal-outlet';\nexport * from './portal-directives';\nexport * from './portal-injector';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"]},"metadata":{},"sourceType":"module"}